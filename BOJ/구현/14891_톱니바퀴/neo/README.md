## Info
<a href="https://www.acmicpc.net/problem/14891" rel="nofollow">14891 톱니바퀴</a>

## ❗ 풀이 방법

1. **톱니바퀴 객체를 구현한다.**
    1. 톱니바퀴 객체는 톱니들을 저장하는 LinkedList를 가지고있다. LinkedList는 삽입, 삭제가 빈번하게 일어날 떄 쓰는 리스트이고, 리스트의 마지막 값과 제일 처음 값을 제거하고 삽입할 수 있기 때문에 사용했다.
    2. 시계 방향, 반시계 방향으로 회전하는 메서드를 구현한다.
    3. 오른쪽으로 맞닿는 톱니와 왼쪽으로 맞닿는 톱니를 업데이트 시켜주는 메서드를 구현한다. 이 메서드는 모든 톱니바퀴가 회전하고 나서 맞닿는 톱니를 업데이트 시킬 때 사용한다.
2. **dfs를 통해서 맞닿는 톱니가 서로 다른극이면 회전시킨다.**
    1. 제일 처음 dfs가 동작할 때에는 왼쪽, 오른쪽으로 탐색하는 코드를 동작시킨다.
    2. 탐색할 때 마다 기어의 회전 방향도 전의 방향이랑 반전시켜주고, 맞닿는 톱니가 서로 다르면 회전시킨 다음 더 탐색하고 아니면 종료한다.
3. **dfs가 다 돌면, 맞닿는 톱니를 최신화 시킨다.**


## 🙂 새로 알게된 점

* 해당 문제를 풀면서 정말 많이 반성했었다. 평소 문제를 한 1분동안 보고 바로 코드로 구현하는 습관이 있었는데, 이는 매우 잘못된 행동이라는 것을 깨달았다.
* 톱니바퀴 문제를 풀면서 간단하게 객체를 만들고, dfs를 돌리면 되겠다는 생각으로 접근을 했었다. 하지만, 모든 로직이 다 맞다고 생각했는데도 틀려서 3시간 이상을 소모했다. 나중에 문제를 파악해보니 문제에서 제시한 조건이 틀리다는 사실을 알게되었다.
* 예시로, 총 7시의 톱니가 주어질 때 12시 방향부터 시계 방향으로 차례대로 주어진다고 했었다. 하지만 나는 반시계 방향으로 차례대로 주어진다고 착각하고, 맞닿는 기어의 조건을 잘못 줘서 계속 오답이 나오고 있는 상황이였다.
* 이는 코드를 치는 것 보다 문제를 정확하게 이해하고 설계를 한 다음에 푸는 것이 더 중요하다는 것을 깨닫게 해주었고, 앞으로 문제를 바로 풀기보다 최소 10분이상 문제를 읽어보고 정리한뒤에 설계해서 풀어야겠다.
* 추가로, 시뮬레이션 문제는 약한 것 같아서 많이 풀어볼 필요가 있겠다고 생각했다.

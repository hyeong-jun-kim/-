## Info
<a href="https://www.acmicpc.net/problem/14891" rel="nofollow">14891 톱니바퀴</a>

## ❗ 풀이 방법

### 입력 변수
톱니바퀴의 상태를 담은 char[][] wheel
회전횟수 int k
회전시킨 톱니바퀴 번호, 방향이 담긴 arr

### 로직 흐름
1. k번의 회전 시뮬레이션 실행.
2. 회전시킬 톱니바퀴 인덱스 idx, 회전방향 dir 기록
3. 회전시킬 톱니바퀴의 왼쪽과 오른쪽을 기록 후 회전
4. 3에서 회전시킨 톱니바퀴를 기준으로 오른쪽 톱니바퀴, 왼쪽 톱니바퀴를 나누어서 회전시키기
5. 1번의 반복문을 완료한 후 점수를 계산하여 return

### 시뮬레이션 로직 구조
idx 톱니바퀴를 시계방향으로 회전시켰다면

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx 톱니바퀴를 기준으로 오른쪽 톱니바퀴들을 회전시키기

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx 톱니바퀴를 기준으로 왼쪽 톱니바퀴들을 회전시키기

idx 톱니바퀴를 반시계방향으로 회전시켰다면

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx 톱니바퀴를 기준으로 오른쪽 톱니바퀴들을 회전시키기

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx 톱니바퀴를 기준으로 왼쪽 톱니바퀴들을 회전시키기


### 선언한 회전시키는 메서드 rotate(바퀴정보, 회전시킬 방향, 회전시킬 바퀴 인덱스) 설명
* 방향이 시계방향이라면

  * 맨 뒤의 것을 맨앞으로 당기고, 전부 뒤로 밀기

* 방향이 반시계방향이라면

  * 맨 앞의 것을 맨 뒤로 옮기고 전부 맨 앞으로 당기기
 

## 🙂 새로 알게된 점

* 문제의 요구사항대로 침착하게 구현하는 문제였는데 손부터 움직여 코딩해버리니 문제를 푸는데 2시간 30분이 걸렸다.. 이런 구현 문제는 글로 쓰거나 머릿속(사실상 불가능)으로 한번 로직의 흐름을 정리하고 코딩을 하는 것이 중요할 것 같다. 또한 메서드 하나에서 너무 많은 코딩을 해버리게 되면 중간에 길을 잃을수도 있으므로, 반복되는 로직은 꼭 밖으로 빼서 메서드화 시키는 것이 중요하다.

## Info
<a href="https://www.acmicpc.net/problem/1325" rel="nofollow">1325_효율적인_해킹</a>

## ❗ 풀이 방법
- 간단한줄 알았는데, 시간 초과와 메모리 초과를 고려해서 문제를 푸느라 꽤나 까다로웠던 문제이다.
    - 특히 처음 1~3% 채점에서 시간 체크를 깐깐하게해서 10번이상 재제출을 했었다.
- 문제에서 a가 b를 신뢰하면 b를 통해서 a를 해킹할 수 있다고 했다. 이를 그래프로 표현하면 b → a로 가는 단방향 그래프이다.
- 해당 문제는 BFS, DFS로도 풀 수 있는데, BFS로 풀었다. 단방향 인접 그래프를 형성하고, bfs를 통해 컴퓨터에서 연결할 수 있는 컴퓨터 갯수를 구하고, 연결할 수 있는 컴퓨터가 최대인 노드를 답으로 출력하게 하면 된다.

## 🙂 새로 알게된 점
- **hashset.clear()의 시간 복잡도는 O(n)이다.**
    - visited 배열을 루프문을 돌 때마다 초기화 시켜주는 것이 아깝다고 생각해 hashSet을 통해 메모리를 줄일려고 했었다.
    - 각 루프문마다 초기화를 시켜줄려고 clear 메서드를 실행했는데, 이는 O(n)이라 시간 초과가 떳었다.
- **해당 문제는 dfs + dp를 조합해서 풀리지 않는다.**
    - 처음에 하위 노드별로 연결할 수 있는 컴퓨터의 갯수를 구해서 상위 노드를 업데이트 시켜주는 방식으로 풀었었다. 하지만 계속 틀렸었고, 생각해보니까 해당 문제는 무조건 단방향 그래프가 아니라 양방향 그래프 (사이클이 생길수도 있는 문제였다.)
    - 만약 2→3, 2→4 를 가리키고 있는데 1→2, 2→1을 가리키면, dp[1] = 4이고, dp[3]으로 나오게된다. 하지만 1은 자기 자신을 제외한 컴퓨터, 3가지를 해킹할 수 있으므로 틀린 답이 나오는걸 확인할 수 있다.


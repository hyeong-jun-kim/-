## Info
<a href="https://www.acmicpc.net/problem/9466" rel="nofollow">9466_텀 프로젝트</a>

## ❗ 풀이 방법
- 해당 문제는 dfs를 통해 사이클이 형성되는 것을 처리하면 풀리는 문제이다. 또한 시간 복잡도를 깐깐하게 체크하여 시간 초과가 안나게 해야한다. (80% 테스트 케이스에서 시간초과 빡빡하게 검사함)
- 사이클이 형성되는 것을 탐지하기 위해 순서가 보장되는 LinkedHashSet을 사용했다.
    - visited 배열을 사용하면 for문을 돌때마다 메모리 초과가 발생할 수 있으므로 set.clear()을 통해 메모리 초과가 뜨는 것을 방지했다.
    - 특정 노드에 방문시 set.contains(int node)를 검사한다, 만약 해당 노드가 이미 set에 존재할경우, 사이클이 만들어졌다고 판단한다.
    - set 요소들을 탐색하고, 해당 노드가 나온 뒤에 모든 노드는 status가 1로 바뀐다, 여기서 status 1은 팀 프로젝트가 결성되었다는걸 말한다.
- dfs를 탐색을 할 때, status[node] = -1을 하면서 진행하는 이유는 사이클이 형성이 되면 set 탐색을 통해 status = 1로 바뀌고, 사이클이 형성이 안되는 노드(팀이 형성이 안되는 경우)들은 -1로 바뀐다.
    - 이를 통해 각 학생들을 기준으로 for문을 돌 때 status가 0이 아닐경우 continue를 진행해서 시간 복잡도를 줄일 수 있다.
    - 또한, dfs를 돌다가 status[node]가 0일 경우 return;을 통해서 시간 복잡도를 줄일 수 있다.

## 🙂 새로 알게된 점
* LinkedHashSet의 사용 용도를 알게되었다, contains는 hashSet이랑 똑같이 O(1)의 시간 복잡도를 가지지만, 살짝 느리다고 한다. 대신에 hashSet은 해시 테이블을 사용해 구현되어서 요소들의 순서는 보장되지 않지만, LinkedHashSet은 테이블과 연결 리스트를 조합해서 사용해 요소들의 순서가 보장된다고 한다.


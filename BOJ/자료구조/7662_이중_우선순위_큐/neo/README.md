## Info
<a href="https://www.acmicpc.net/problem/7662" rel="nofollow">7662 이중 우선순위 큐</a>

## ❗ 풀이 방법

*처음에는 내림차순 정렬로 이진탐색을 이용해서 풀려고했는데 복잡해서 실패했다. 그 다음으로 스택으로 푸는 방안을 생각해서 문제를 풀었다.*
1. 2개의 우선순위 큐를 준비한다 (최소 힙, 최대 힙)
2. 데이터 삽입, 삭제를 기록할 HashMap을 정의한다.
3. INSERT가 생길 때 마다 최소 힙, 최대 힙에 해당 요소를 삽입해주고, HashMap에 기록한다. 그리고 InsertCNT를 +1 증가시킨다.
4. DELETE가 생길 때 조건에 따라서 해당 요소를 힙에서 제거해주고, HashMap에서 해당 요소를 -1한다. 그리고 DeleteCnt를 +1 증가시킨다.
    4-0. InsertCNT== DeleteCnt가 같다면 삭제 연산을 무시한다.
    4-1. 만약에, Map 해당 요소의 Value 값이 0일때는 키를 제거한다.
    4-2. 만약 map에 키가 없으면 다시한번 루프문을 돌게한다. 이부분은 다른 힙에서 요소를 제거했을 경우를 고려한 것이다.
    
5. 모든 연산이 다 끝나면 queue.peek() 메서드를 사용해 min 값과 max 값을 구한다. 
    5-1 만약에 min 또는 max값이 map에서 제거됐다면, min값과 max 값을 구하는 과정을 반복한다. 제거됐다는건 다른 힙에서 이미 처리한 것이기 때문이다.

## 🙂 새로 알게된 점
* 해당 문제는 2일동안 답을 보지않고 하루종일 풀었던 문제이다. 
* 해당 문제를 풀면서 내가 생각한걸 자신감있게 풀면 답은 무조건 나오게된다는 믿음을 가지게 되었다.
* LinkedList의 중간 삽입 시간 복잡도는 O(n)인 것을 알게되었다.
